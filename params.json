{"name":"Drop","tagline":"mvc / ioc microframework for Apache Flex","body":"# Drop\r\n\r\n<img src=\"/docs/logo.png\" align=\"right\"></img>\r\nMinimalistic, hybrid MVC / IoC micro-architecture framework for ActionScript on Apache Flex and AIR platforms.\r\n\r\nDrop derives from PureMVC and aims to minimize implementation approach discordance, forcing to write bug-safe and consistent solutions with less boilerplate code, also introducing typed notification model and strong notion of *Separation of Concerns* concept.\r\n\r\nHybrid framework features:\r\n* Inversion of Control micro-architecture based on ServiceLocator, called `Context`;\r\n* Model / View / Controller tiers coded in `Services` / `Mediators` / `Controller` classes respectively;\r\n* Strongly-typed notification & delegation model based on Actor Interfaces.\r\n\r\nAll the code samples below are taken from the [drop-as3-example](../drop-as3-example/src/main/flex) subproject found within the repository.\r\n\r\n## Architecture\r\n\r\nIn essence framework breaks down a system into independable classes called Actors, split into logical tiers (Model, View, Controller), each concerned with specific system aspect and communicating with other Actors via well-defined interfaces. All Actor instanes are stored in a single Service Locator object, called Context, that allows to resolve Actors by their interface.\r\n\r\nActors come in three types:\r\n* Services (and Proxies) that represent Model layer,\r\n* Mediators that represent View layer,\r\n* Controllers that represent Controller layer.\r\n\r\nActors are coded in independent, robust manner, following specific rules explained below.\r\n\r\n\r\n## Anatomy\r\n\r\nTypical application / library written on drop framework has the following structure:\r\n```\r\norg.dropframework.*           → included framework sources\r\nappname                       → application root\r\n └ actors                       → root for internal communication interfaces (actors)\r\n    └ singletones                 → actor interfaces with single implementation: I<...>\r\n    └ notifications               → actor interfaces with multiple implementation: IOn<...>\r\n └ commons                      → root for all shared generic classes\r\n    └ components                  → shared generic components\r\n    └ utils                       → shared generic utility classes\r\n └ controller                   → root for business logic controllers\r\n └ model                        → root for model classes\r\n    └ services                    → proxies, services, data access objects\r\n    └ vos                         → value objects, entities, data transfer objects\r\n └ view                         → root for views and mediators\r\n```\r\n \r\nAs explained below, application written on Drop consists of logic processing classes called Actors that control specific system aspects and communicate with each other via well-defined Interfaces.\r\n\r\n \r\n### The appname/actors directory\r\n\r\nThe [appname/actors](../drop-as3-example/src/main/flex/example/actors) directory usually contains a single [GlobalContext](../drop-as3-example/src/main/flex/example/actors/GlobalContext.as) class which serves as a ServiceLocator for resolving Actors, and the Actor communication interfaces themselves. Actor interfaces are split into two groups:\r\n* **singletones** - interfaces that start with `I<...>` name prefix and define API for managers, commands, workers, services of which there is a single implementation within the system.\r\n* **notifications** - interfaces that start with `IOn<...>` name prefix and defined API for actors that listen for specific events or actions happening within the system.\r\n\r\nExample of Singletone interfaces:\r\n* [ISheepHerdController.as](../drop-as3-example/src/main/flex/example/actors/singletones/ISheepHerdController.as) \r\n* [IWeatherService.as](../drop-as3-example/src/main/flex/example/actors/singletones/IWeatherService.as) \r\n\r\nAnd Notification interfaces:\r\n* [IOnSheepCountChanged.as](../drop-as3-example/src/main/flex/example/actors/notifications/IOnSheepCountChanged.as)\r\n* [IOnWeatherChanged.as](../drop-as3-example/src/main/flex/example/actors/notifications/IOnWeatherChanged.as)\r\n\r\n\r\n#### Actors communication\r\n\r\nCore idea is that **Actors do not communicate directly**, instead they resolve each other via [GlobalContext](../drop-as3-example/src/main/flex/example/actors/GlobalContext.as) by specific Actor interface defined in `appname/actors` package and then invoke required methods. Following `Context` methods can be used to resolve the Actors:\r\n* `.instanceOf (type : Class) : IConcernedActor` - finds one and only one Actor instance of the specified interface, fails with Error if more than 1 Actors found;\r\n* `.arrayOf (type : Class) : Array` - finds an array of Actors for specified interface;\r\n* `.invoke (type : Class, callback : Function) : void` - executes supplied callback function with every Actor of the specified interface as an argument. Handy for notifying multiple Actors.\r\n\r\nThis approach aims to decouple the system components for better maintainability. This way, `appname/actors` directory serves as a collection of interfaces specifying the internal system mechanics.\r\n\r\n> **tip:** Generally it is adviced to rely on notification interfaces versus singletone ones where possible as they allow for better loose coupling.\r\n\r\n \r\n### The appname/commons directory\r\n\r\nThe [appname/commons](../drop-as3-example/src/main/flex/example/commons) directory contains all components, abstractions, utilities and support modules that are:\r\n* generic enough to be reused or means to be extended for the use;\r\n* do not handle any application business logic directrly.\r\n\r\nDirectory content is rather custom, in case of Apache Flex application it is adviced to have a `components` sub package to contain all the shared and reusable components, and `utils` directory for various utilities.\r\n\r\nFramework does not bundle any 3rd party utilities and components library. For utilities, such as those working with Objects, Strings, ByteArrays, Logging system etc. there are few good free options available, such as as3commons library that can found here: http://www.as3commons.org.\r\n\r\n\r\n### The appname/controller directory\r\n\r\nControllers are Actors that contain business logic and / or orchestrate other Actors such as Services and Mediators are stored in [appname/controller](../drop-as3-example/src/main/flex/example/controller) directory. Controllers include executable commands triggered directly or by notification, various system managers, complex execution sequences or aspect controllers.\r\n\r\nControllers decouple the complex business logic and facade that behind Actor interfaces, see the [Shepherd.as](../drop-as3-example/src/main/flex/example/controller/Shepherd.as).\r\n\r\nNotice the way notification broadcasted to every Actor implementing the `IOnSheepCountChanged` and `IOnDisasterHappened` interface using the `invoke` method:\r\n```actionscript\r\ninvoke(IOnSheepCountChanged, function (a : IOnSheepCountChanged) : void\r\n        { a.onSheepCountChanged(_sheepCount); });\r\n```\r\n\r\nEvery Controller automatically registers itself within the GlobalContext upon initialization.\r\n\r\n> **tip:** Strictly, Controllers are not always required as Mediators and Services (see below) can and should contain application logic related to presentation and model layers. Use Controllers to decouple and manage the non-presentation and non-model related logic, control a system aspect or orchestrate other Actors via their interfaces.\r\n\r\n\r\n### The appname/model directory\r\n\r\nModel layer is at heart of every application as it defines Domain Objects and Domain API and can be found in [appname/model](../drop-as3-example/src/main/flex/example/model) directory. Framework allows to follow various practices to define the Model, for instance applying a Domain Driven Development approach, but in core manages the two types of classes:\r\n* **data access objects** - found in [appname/model/services](../drop-as3-example/src/main/flex/example/model/services), these are services, proxies, data stubs, remote endpoints etc. that provide a data feed for the application to present or means to control and modify the application data. Drop provides `Service` and `Proxy` basic Actor classes to represent those.\r\n* **data transfer objects** - found in [appname/model/vos](../drop-as3-example/src/main/flex/example/model/vos), these are value objects and entities that represent the Domain.\r\n\r\nNo application business or presentation logic should be handled within the Model layer. Controllers and Mediators should be used instead.\r\n\r\n[WeatherService.as](../drop-as3-example/src/main/flex/example/model/services/WeatherService.as) is a Service example, and [Weather.as](../drop-as3-example/src/main/flex/example/model/vos/Weather.as) is a Value Object.\r\n\r\n> **tip:** Services and Proxies may use direct response mechanics via IOn interface or indirect notification broadcasting via IOn interface, whichever preferred and consistent with an approach chosen by development team.\r\n\r\n\r\n### The appname/view directory\r\n\r\nThe [appname/view](../drop-as3-example/src/main/flex/example/view) directory is where the hierarchy of visual elements and containers defined. Classes there can be of 3 following types:\r\n* **views** - all visual display objects, controls and custom ui components that shown on a screen, usually coded in MXML, for example `MessagePanel.mxml`;\r\n* **skins** - flex 4 skin classes used for applying layout and skinning parameters to the View components, for instance `MessagePanelSkin.as`;\r\n* **mediators** - actors that listen to View Events dispatched by Views; control Views by modifying properties and data providers on them; serving as gateways to the rest of a system, including controllers, services and other Mediators. For example, `MessagePanelMediator.as`.\r\n\r\nGeneral rule in defining Views is **to keep each View as logic unaware and thin as possible, delegating all the business to Mediators**. Views should know nothing on Mediators they're assigned to, be totally separate from the system, and may only:\r\n* include other views;\r\n* broadcast events of special type `ViewEvent` caught by Mediators;\r\n* expose public methods to set properties or apply data providers.\r\n\r\nIn turn, every Mediator must:\r\n* perform a business logic only of a single View it is assigned to;\r\n* delegate non-View specific logic to other mediators, services or controllers responsible for it.\r\n\r\n\r\n#### ViewEvent dispatching\r\n\r\nView Event dispatching can be seen in a [HerdPanel.mxml](../drop-as3-example/src/main/flex/example/view/herd/HerdPanel.mxml):\r\n\r\n```actionscript\r\n<s:Panel xmlns:fx=\"http://ns.adobe.com/mxml/2009\"\r\n         xmlns:s=\"library://ns.adobe.com/flex/spark\">\r\n    <fx:Script><![CDATA[\r\n        public static const A_ADD_SHEEP_CLICKED : String\r\n               = ViewEvent.uniqueName(\"A_ADD_SHEEP_CLICKED\");\r\n              \r\n        private function addSheepButton_clickHandler(event:MouseEvent):void\r\n        {\r\n            dispatchEvent(ViewEvent.of(A_ADD_SHEEP_CLICKED, event));\r\n        }\r\n    ]]></fx:Script>\r\n    <s:Button id=\"addSheepButton\" label=\"Add Sheep\"\r\n              verticalCenter=\"0\" horizontalCenter=\"0\"\r\n              click=\"addSheepButton_clickHandler(event)\"/>\r\n</s:Panel>\r\n```\r\n\r\nAnd listening in a [HerdPanelMediator.mxml](../drop-as3-example/src/main/flex/example/view/herd/HerdPanelMediator.as):\r\n\r\n```actionscript\r\npublic class HerdPanelMediator\r\n        extends Mediator\r\n{\r\n    public function HerdPanelMediator(view : HerdPanel)\r\n    {\r\n        super(GlobalContext.instance, view);\r\n        adapter.onActions(\r\n                [HerdPanel.A_ADD_SHEEP_CLICKED],\r\n                function (event : ViewEvent) : void\r\n                {\r\n                    sheepHerdController.addSheep();\r\n                });\r\n    }\r\n\r\n    private function get sheepHerdController() : ISheepHerdController\r\n    {\r\n        return instanceOf(ISheepHerdController) as ISheepHerdController;\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### Listening for external notifications\r\n\r\n[MessagePanel.mxml](../drop-as3-example/src/main/flex/example/view/message/MessagePanel.mxml) exposes `dataProvider` setter that applies message text to the label control:\r\n\r\n```actionscript\r\n<?xml version=\"1.0\"?>\r\n<s:Panel xmlns:fx=\"http://ns.adobe.com/mxml/2009\"\r\n         xmlns:s=\"library://ns.adobe.com/flex/spark\">\r\n    <fx:Script>\r\n        <![CDATA[\r\n        public function set dataProvider (label : String) : void\r\n        {\r\n            statusLabel.text = label;\r\n        }\r\n        ]]>\r\n    </fx:Script>\r\n    <s:Label id=\"statusLabel\"\r\n             verticalCenter=\"0\" horizontalCenter=\"0\"/>\r\n</s:Panel>\r\n```\r\n\r\n[MessagePanelMediator.as](../drop-as3-example/src/main/flex/example/view/message/MessagePanelMediator.as) listens for `IOnSheepCountChanged` notification and applies `dataProvider` to the `MessagePanel` View:\r\n\r\n```actionscript\r\npublic class MessagePanelMediator\r\n    extends Mediator\r\n    implements IOnSheepCountChanged\r\n{\r\n    public function MessagePanelMediator(view : MessagePanel)\r\n    {\r\n        super(GlobalContext.instance, view);\r\n    }\r\n\r\n    public function onSheepCountChanged(sheepCount : uint) : void\r\n    {\r\n        messagePanel.dataProvider = (sheepCount != 0) ?\r\n                \"Sheep herd has \" + sheepCount + \" sheeps\" :\r\n                \"Sheep herd is empty\";\r\n    }\r\n\r\n    public function onDisasterHappened(sheepCount : uint, description : String) : void\r\n    {\r\n        messagePanel.dataProvider = description;\r\n    }\r\n\r\n    private function get messagePanel() : MessagePanel\r\n    {\r\n        return adapter.view as MessagePanel;\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Initialization\r\n\r\nOnce [ApplicationView](../drop-as3-example/src/main/flex/example/view/ExampleApplication.mxml) created, an [ApplicationMediator](../drop-as3-example/src/main/flex/example/view/ExampleApplicationMediator.as) is initialized, which in turn creates all the system actors.\r\n\r\n```actionscript\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<s:Application xmlns:s=\"library://ns.adobe.com/flex/spark\"\r\n               xmlns:fx=\"http://ns.adobe.com/mxml/2009\"\r\n               creationComplete=\"creationCompleteHandler(event)\">\r\n    <fx:Script><![CDATA[\r\n        import mx.events.FlexEvent;\r\n        private function creationCompleteHandler (event : FlexEvent) : void\r\n        {\r\n            new ExampleApplicationMediator(this);\r\n        }\r\n    ]]></fx:Script>\r\n    <!-- view components here ... -->\r\n</s:Application>\r\n```\r\n\r\nAnd Application Mediator: \r\n\r\n```actionscript\r\npublic class ExampleApplicationMediator\r\n    extends Mediator\r\n{\r\n    public function ExampleApplicationMediator(view : ExampleApplication)\r\n    {\r\n        super(GlobalContext.instance, view);\r\n\r\n        /* initializing model layer */\r\n        new WeatherService();\r\n\r\n        /* initializing controller layer */\r\n        new Shepherd();\r\n\r\n        /* initializing mediators for included components */\r\n        new HerdPanelMediator(view.herdPanel);\r\n        new MessagePanelMediator(view.messagePanel);\r\n\r\n        /* once actors initialized, sending the ready notification */\r\n        invoke(IOnApplicationReady, function (a : IOnApplicationReady) : void\r\n                { a.onApplicationReady(); });\r\n    }\r\n}\r\n```\r\n\r\nMediators initialization happens hierarchically with parent Mediators initializing Mediators for the child views.\r\n\r\n> **tip:** Generally it is a good idea to dispatch IOnApplicationReady notification in a way shown above once all Actors created and execute all initial data retrieving, view preparing and internal processes launch within listeners in a safe manner, rather than in Actor contstructors.\r\n\r\n\r\n## How to use\r\n\r\n- Get familiar with the framework structure by going through the simple drop-as3-example project.\r\n- Checkout and include the sources of a drop-as3 project.\r\n- Have fun playing, changing and creating!\r\n\r\nDrop is designed for modification and extension. For a particular project it might be decided to introduce additional or modified Actor types structure.\r\n\r\nWhatever architecture is followed, it must be made sure every Actor is only concerned with the aspect it's type designed to handle, and the actors communicate in decoupled manner via well-defined communication interfaces.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}